# Coroutine

>## 🤔 **Coroutine 은 어떻게 작업을 최적화 할까**

<br>

### **Thread 구조와 다중 Thread 작업성의 필요성**

하나의 프로세스 에는 여러 *Thread* 가 있다

![image](https://cdn.discordapp.com/attachments/892277737266499614/960679403988344912/unknown.png)

다음은 JVM 프로세스의 **Thread** 구조이다

JVM 프로세스는 **Main Thread** 가 종료되면 강제로 종료되고 프로세스에 속한 **Thread** 들도 함께 강제로 종료된다

그런데 위의 사진에서는 *Main Thread* 를 제외한 2개의 *Thread* 가 더 있는걸 볼 수 있다

이 *Thread* 들은 *Main Thread* 와 동일하게 작업을 수행할 수 있고 종료되어도 **다른 Thread 에 영향을 미치지 않는다**

이를 **안드로이드** 에 적용하면 *Main Thread* 는 가장 중요한 *Thread* 로 

**이 Thread 는 UI 를 그려주고 사용자의 입력을 받아 그 입력을 전달해주는 Thread 이다**

그런데 이 **Thread**가 어떠한 작업 (부하가 높은) 에 의해 블로킹 된다면 앱에서 멈춤 현상이 생길 수 있다 

*이럴땐 다른 Thread 를 생성해 Thread 에 이 Thread 에 높은 부하를 주는 작업을 수행하도록 해야한다*

<br>

---

### **기존방식의 한계**

<br>

이러한 문제들을 위해 

<br>

```

1. Runnable 인터페이스를 구현해줄 클래스를 만든 후에 Thread 에 클래스를 넣어 실행하는 방식

2. Thread Pool 을 구성해 작업을 던지는 방식

3. Rx 라이브러리를 이용해 데이터를 발행하는 Thread 와 구독하는 Thread 를 손쉽게 제어하는 방식

```

<br>

다음과 같은 방식들을 사용했다

<br>

다음과 같은 방식들의 문제는 작업의 단위가 **Thread** 라는 점이다

작업의 단위가 **Thread** 인 것이 문제가 되는 이유는 어떤 **Thread** 가 다른 **Thread** 로 부터 작업을

 기다려야 할 때 **블로킹** 이 생기게 되면 해당 **Thread** 에서 하는 작업이 끝날 때까지
 기다려야 하기 때문에
 
  자원이 낭비가 된다 아래를 통해 사례를 확인 할 수 있다

  <br>

![예시](https://cdn.discordapp.com/attachments/892277737266499614/960776128899993640/unknown.png)

<br>

사진에서 **Thread1** 이 *작업1* 수행 도중 **Thread2** 의 작업2 의 결과물이 **Thread1** 의 *작업1* 을 수행하는데

필요해졌다고 하자 이때 **Thread1** 은 **Thread2** 의 *작업2* 에서 어떠한 결과가 나올때까지

아무것도 하는 일 없이 블로킹이 된다 위와같이 짧은 시간동안의 블로킹이라면 다행이지만

실제 상황에서는 **Thread** 의 성능이 상당히 저하 될 수 있다

<br>

---

### **Coroutine 에서의 해결방법**

<br>

**Coroutine** 에서도 **Thread** 라는 작업 단위를 사용하지만 **Thread** 내부에 작은 **Thread** 처럼

 동작하는 **Coroutine** 이 존재한다
 
<br>

  ![image](https://cdn.discordapp.com/attachments/892277737266499614/960781630975406110/unknown.png)

  <br>

  **Thread** 하나를 **일시중단**이 되는 다중 경량 **Thread** 처럼 활용하는 것이 **Coroutine** 이다

![image](https://cdn.discordapp.com/attachments/892277737266499614/960783008753934366/unknown.png)

<br>

위의 사진은 아까와 같은 상황을 Coroutine 을 이용해 해결하는 과정이다

<br>

**Thread1** 이 **Coroutine** 2개를 생성 한 후 **Coroutine1** 에게 작업1 수행 시키고 **Thread2** 에서는 

**작업2** 가 수행된다, **Coroutine1** 은 작업도중 **Thread2** 로부터 결과가 필요해지지만

 **Thread2** **작업2** 가 아직 끝나지 않아 **작업1** 을 진행 할 수 없게 된다

이때 **Coroutine1** 은 **Thread1** 을 블로킹 하는 대신 자신의 작업을 일시중단 시키고 **Coroutine2** 에 

**Thread1** 리소스 사용 권한을 넘겨준다 이렇게 되면 **Thread1** 의 **Coroutine2** 가 

**작업3** 을 수행 할 수 있게되고 그렇게 **Thread2** 의 작업이 종료되면 **작업3** 을 수행하던

 **Coroutine2** 가 자신의 작업을 마무리하고 자신을 일시중단 시킨다

 이에따라 **Thread1** 의 제어권한이 **Coroutine1** 로 돌아오고 **Thread1** 이 **Thread2** 의 결과값을 

 받아오면 **Coroutine1** 이 **작업1** 을 재개한다

 <br>

이렇게 되면 블로킹은 줄어들어 **Thread1** 의 리소스를 최대한으로 사용 할 수 있다

*이로써 Coroutine 이 Thread 안에서 실행되는 일시중단 가능한 작업의 단위임을 알 수 있다*











