# 변수의 다양한 사용법

> **😉 기본적 변수의 개념**
---

var 은 한번 할당한 객체가 있더라도 다른 객체로 변경 후 할당 할 수 있고

```
var a = Person("오종진", 2005)
a = Person("종진", 05)
```

val 은 한번 객체를 할당하면 다시 할당된 객체를 변경 할 수 없다

```
var a = Person("오종진", 2005)
// a = Person("종진", 05)
```

이때 알아야 할 것은

val 은 할당된 객체를 바꿀 순 없지만 

**객체 내부의 속성을 바꿀수 없는 것은 아니라는 것이다**

이때 절대 변경이 불가능한 것도 있는데

그것이 바로 **상수(const)** 이다

<br>

> **const**
---

상수는 말 그대로 컴파일 시점에 결정된 절대 바꿀 수 없는 값이다

```
const val BASE_URL = "https:// ~~ "
```

선언은 다음과 같이 *val* 앞에 *const* 를 붙여 선언하고

상수의 이름은 의례적으로 대문자를 사용한다

상수로 선언될 수 있는 값은 기본 자료형만 가능하고

런타임에 생성 가능한 일반적인 다른 클래스의 객체들은 담을 수 없다

<br>

 장소는 클래스의 속성이나 지역변수가 아닌

 ```
 /* class Ex {
    const val BASE_URL = "https:// ~~ "
 }

 fun ex {
    const val BASE_URL = "https:// ~~ "
 } */

 companion object {
    const val BASE_URL = "https:// ~~ "
 }

 ```

 companion object 안에 선언하고 객체의 생성과 관계없이

 class 와 관계된 고정적인 값으로만 사용해야한다

 >> **const > 구현**

 ```
 fun main() {
    val food = FoodCourt()

    food.searchPrice(FoodCourt.FOOD_PASTA)
    food.searchPrice(FoodCourt.FOOD_PIZZA)
}

class FoodCourt {

    fun searchPrice(name: String) {
        val price = when(name) {
            FOOD_PASTA -> 12000
            FOOD_PIZZA -> 13000
            else -> 0
        }

        println("${name}의 가격은 ${price}원 입니다")
    }

    companion object {
        const val FOOD_PASTA = "파스타"
        const val FOOD_PIZZA = "피자"
    }
}
 ```
 결과값

 ```
 파스타의 가격은 12000원 입니다
 피자의 가격은 13000원 입니다
 ```

 searchPrice()를 이용해 가격을 출력하는 간단한 코드이다


 ```
companion object {
    const val FOOD_PASTA = "파스타"
    const val FOOD_PIZZA = "피자"
}
 ```

FoodCourt 클래스를 이용하는 사람들은 어떤 음식들이 있는지

알 수 있는 방법이 없기에 companion object 를 선언한 후

내부에 searchPrice() 에서 사용할 음식 이름들을 상수로 선언해주었다

이때 이러한 상황을 상수가 자주 사용되는 예라고 볼 수 있다

 >> **const > 상수를 사용하는 이유**

위의 내용들만 보면 상수를 꼭 사용해야 하는 특별한 이유를 알 수 없지만

변수를 사용하게 되면 런타임시 객체를 생성하는데 시간이 더 소요돼서 **성능의 하락이 있다** 

이 때문에 늘 고정적으로 사용할 값은 상수를 통해 

객체의 생성없이 메모리에 값을 고정하여 사용함으로써

성능을 향상 시킬 수 있다




